<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Kenya GIS Portal - KJ Hub</title>

    <!-- Tailwind CSS for modern, responsive styling -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts: Inter for a clean, professional look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Leaflet CSS for the map -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" xintegrity="sha512-xodL+v3i/2d7Fz47u5fDk08iY92p2aW3s8G1Gz3o3+3sW4n3z9a8z6+8f3+4r5+3g6+8+7g=" crossorigin=""/>

    <!-- DataTables CSS for the attribute table -->
    <link rel="stylesheet" href="https://cdn.datatables.net/1.13.6/css/dataTables.tailwindcss.min.css"/>
    
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Custom CSS for the layout and specific elements -->
    <style>
        /* General page and typography setup */
        html, body {
            height: 100%;
            margin: 0;
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
        }

        /* Main container and layout using flexbox */
        .main-container {
            display: flex;
            height: calc(100vh - 64px); /* Subtract navbar height */
        }
        
        /* Sidebar styling */
        .sidebar {
            flex-basis: 30%; /* Take up 30% of the width */
            overflow-y: auto;
            background-color: #ffffff;
            border-right: 1px solid #e5e7eb;
            padding: 1rem;
            box-shadow: 2px 0 8px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
        }

        /* Map container styling */
        #map {
            flex-grow: 1; /* Take up the remaining space */
            height: 100%;
            z-index: 1;
        }

        /* Header for sections in the sidebar */
        .sidebar h5 {
            color: #1f2937; /* Dark gray */
            font-weight: 600;
            margin-bottom: 0.75rem;
        }

        /* Layer card styling */
        .layer-card {
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            margin-bottom: 0.75rem;
            padding: 0.75rem;
            background-color: #f9fafb;
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }

        .layer-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        /* Color picker input styling */
        .color-input {
            width: 2rem;
            height: 2rem;
            padding: 0;
            border: 1px solid #d1d5db;
            border-radius: 0.25rem;
            cursor: pointer;
        }

        /* Button group spacing */
        .btn-group-custom {
            display: flex;
            gap: 0.5rem;
        }

        /* Scrolling areas for layers and tables */
        #layersList, #tableArea {
            max-height: 45vh;
            overflow-y: auto;
        }

        /* Leaflet layer highlight style */
        .highlight-feature {
            color: #facc15 !important; /* Tailwind yellow-400 */
            fillColor: #facc15 !important;
            fillOpacity: 0.8 !important;
            weight: 4 !important;
            opacity: 1 !important;
        }

        /* DataTable row selection style */
        .selected-row {
            background-color: #fffbeb !important; /* Tailwind yellow-50 */
        }
        
        /* Table header alignment */
        .dt-head-left {
            text-align: left;
        }

        /* Custom scrollbar for a nicer look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Toast notification styling */
        .toast-container {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        .toast {
            background-color: #1f2937;
            color: #ffffff;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: opacity 0.3s ease-in-out;
            opacity: 0;
            transform: translateY(20px);
        }
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
    </style>
</head>
<body class="bg-gray-100">

<!--
    ========================================
    MAIN UI STRUCTURE
    ========================================
-->

<!-- Navbar -->
<nav class="bg-gray-800 p-4 shadow-md flex justify-between items-center z-50 sticky top-0">
    <div class="text-white text-2xl font-bold">Kenya GIS Portal - KJ Hub</div>
    <div class="flex items-center space-x-4">
        <button id="uploadBtn" class="bg-emerald-500 text-white font-semibold py-2 px-4 rounded-md shadow-lg hover:bg-emerald-600 transition-colors duration-200">
            <i class="fas fa-cloud-upload-alt mr-2"></i>Upload Layer
        </button>
        <button id="refreshLayersBtn" class="bg-gray-600 text-white py-2 px-4 rounded-md shadow-lg hover:bg-gray-700 transition-colors duration-200">
            <i class="fas fa-sync-alt"></i>
        </button>
    </div>
</nav>

<!-- Main content area with sidebar and map -->
<div class="main-container">
    <!-- Sidebar for layers, table, and controls -->
    <aside class="sidebar">
        <!-- Layer Management Section -->
        <div class="flex-1">
            <div class="flex justify-between items-center mb-4">
                <h5 class="text-lg">Available Layers</h5>
                <button id="mergeLayersBtn" class="bg-sky-500 text-white font-semibold py-1 px-3 rounded-md shadow hover:bg-sky-600 transition-colors duration-200 text-sm">
                    <i class="fas fa-layer-group mr-1"></i>Merge Selected
                </button>
            </div>
            <div id="layersList" class="space-y-3">
                <p class="text-center text-gray-500 italic p-4 loading-message">Loading layers...</p>
            </div>
        </div>

        <hr class="my-4 border-gray-300" />

        <!-- Attribute Table Section -->
        <div class="flex-1 mt-4">
            <h5 class="text-lg">Attribute Table</h5>
            <div id="tableArea" class="bg-gray-50 rounded-lg p-2 shadow-inner">
                <p class="text-center text-gray-500 p-4">Select a layer to view its data.</p>
            </div>
        </div>

        <!-- Selection Action Buttons -->
        <div class="mt-6 flex flex-col sm:flex-row justify-center items-center gap-4">
            <button id="createSelectionLayerBtn" class="bg-yellow-400 text-gray-800 font-semibold py-2 px-4 rounded-full shadow-lg hover:bg-yellow-500 transition-colors duration-200" disabled>
                <i class="fas fa-clone mr-2"></i>Create Selection Layer
            </button>
            <button id="downloadSelectionBtn" class="bg-green-500 text-white font-semibold py-2 px-4 rounded-full shadow-lg hover:bg-green-600 transition-colors duration-200" disabled>
                <i class="fas fa-download mr-2"></i>Download Selection
            </button>
        </div>
    </aside>

    <!-- Map Container -->
    <div id="map" class="shadow-xl rounded-l-lg"></div>
</div>


<!--
    ========================================
    MODAL WINDOWS
    ========================================
-->

<!-- Upload Layer Modal -->
<div id="uploadModal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden justify-center items-center z-[100]">
    <div class="bg-white p-6 rounded-lg shadow-2xl w-full max-w-md">
        <form id="uploadForm" enctype="multipart/form-data">
            <div class="flex justify-between items-center border-b pb-3 mb-4">
                <h5 class="text-xl font-bold">Upload Shapefile (zip)</h5>
                <button type="button" class="text-gray-400 hover:text-gray-600 text-2xl close-modal">&times;</button>
            </div>
            <div class="mb-4">
                <label for="shpFile" class="block text-gray-700 font-semibold mb-2">Choose zipped shapefile archive (.zip)</label>
                <input class="w-full border rounded-lg py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-sky-500" type="file" id="shpFile" name="file" accept=".zip" required/>
            </div>
            <div class="mb-4">
                <label for="tablename" class="block text-gray-700 font-semibold mb-2">New Layer Table Name</label>
                <input class="w-full border rounded-lg py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-sky-500" type="text" id="tablename" name="tablename" placeholder="e.g., my_new_layer" required/>
            </div>
            <div id="uploadStatus" class="mt-4"></div>
            <div class="flex justify-end space-x-3 mt-6">
                <button type="submit" class="bg-emerald-500 text-white font-semibold py-2 px-4 rounded-md shadow-md hover:bg-emerald-600 transition-colors duration-200">Upload</button>
                <button type="button" class="bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-md shadow-md hover:bg-gray-400 transition-colors duration-200 close-modal">Cancel</button>
            </div>
        </form>
    </div>
</div>

<!-- Confirm Delete Modal -->
<div id="deleteModal" class="fixed inset-0 bg-gray-900 bg-opacity-50 hidden justify-center items-center z-[100]">
    <div class="bg-white p-6 rounded-lg shadow-2xl w-full max-w-sm">
        <div class="flex justify-between items-center border-b pb-3 mb-4">
            <h5 class="text-xl font-bold text-red-600">Confirm Deletion</h5>
            <button type="button" class="text-gray-400 hover:text-gray-600 text-2xl close-modal">&times;</button>
        </div>
        <div class="modal-body">
            <p class="text-gray-700">Are you sure you want to delete the layer '<strong id="deleteLayerName"></strong>'? This action cannot be undone.</p>
        </div>
        <div class="flex justify-end space-x-3 mt-6">
            <button type="button" class="bg-gray-300 text-gray-800 font-semibold py-2 px-4 rounded-md shadow-md hover:bg-gray-400 transition-colors duration-200 close-modal">Cancel</button>
            <button type="button" class="bg-red-500 text-white font-semibold py-2 px-4 rounded-md shadow-md hover:bg-red-600 transition-colors duration-200" id="confirmDeleteBtn">Delete</button>
        </div>
    </div>
</div>


<!-- Toast Notification Container -->
<div id="toast-container" class="toast-container"></div>


<!--
    ========================================
    JAVASCRIPT LIBRARIES & CUSTOM SCRIPT
    ========================================
-->

<!-- jQuery for DOM manipulation and AJAX calls -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>

<!-- Leaflet JS for the map -->
<script src="https://unpkg.com/leaflet/dist/leaflet.js" xintegrity="sha512-xodL+v3i/2d7Fz47u5fDk08iY92p2aW3s8G1Gz3o3+3sW4n3z9a8z6+8f3+4r5+3g6+8+7g=" crossorigin=""></script>

<!-- DataTables JS for the attribute table -->
<script src="https://cdn.datatables.net/1.13.6/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/1.13.6/js/dataTables.tailwindcss.min.js"></script>


<script>
    // Global state variables
    // These variables hold the state of the application on the client-side.
    const LAYERS_INITIAL = {{ layers | tojson }};
    let LAYERS = {...LAYERS_INITIAL};
    let leafletLayers = {};
    let geojsonCache = {};
    let activeLayerKey = null;
    let selectedRows = {};
    let highlightedFeatures = new Map();
    let dataTable = null;

    // Initialize the Leaflet map with a default view of Kenya
    const map = L.map('map').setView([0.0236, 37.9062], 6);
    // Add a base tile layer from OpenStreetMap
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);


    /*
    * ========================================
    * CORE UTILITY FUNCTIONS
    * ========================================
    */

    /**
     * Shows a toast notification to the user for feedback.
     * @param {string} message - The message to display.
     * @param {string} type - The type of message (e.g., 'success', 'error', 'info').
     */
    function showToast(message, type = 'info') {
        const toastContainer = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast p-4 rounded-lg shadow-lg text-white ${type === 'success' ? 'bg-green-600' : type === 'error' ? 'bg-red-600' : 'bg-gray-800'}`;
        toast.textContent = message;
        toastContainer.appendChild(toast);
        
        // Use a small delay to trigger the CSS transition
        setTimeout(() => toast.classList.add('show'), 100);

        // Hide the toast after a few seconds
        setTimeout(() => {
            toast.classList.remove('show');
            // Remove the element from the DOM after the transition ends
            setTimeout(() => toast.remove(), 300); 
        }, 5000);
    }

    /**
     * Gets the styling for a layer based on its key and highlight state.
     * @param {string} key - The layer's unique key.
     * @param {boolean} isHighlighted - Whether the feature is currently highlighted.
     * @returns {object} - A Leaflet style object.
     */
    function getLayerStyle(key, isHighlighted = false) {
        const color = LAYERS[key]?.color || '#3b82f6'; // Tailwind blue-500
        const type = LAYERS[key]?.type;
        
        if (type === 'point') {
            return {
                radius: 6,
                fillColor: isHighlighted ? '#facc15' : color, // Highlight with yellow-400
                color: '#1f2937', // Tailwind gray-800
                weight: isHighlighted ? 3 : 1,
                opacity: 1,
                fillOpacity: isHighlighted ? 1 : 0.9,
            };
        } else {
            return {
                color: isHighlighted ? '#facc15' : color,
                weight: isHighlighted ? 4 : 2,
                fillOpacity: isHighlighted ? 0.7 : 0.4,
                opacity: 1,
            };
        }
    }

    /**
     * Fetches GeoJSON data for a layer and adds it to the map.
     * @param {string} key - The layer's unique key.
     * @param {boolean} fitBounds - Whether to zoom the map to the layer's bounds.
     */
    function addLayerToMap(key, fitBounds = false) {
        // Show a loading message
        const layerCard = $(`div[data-key="${key}"]`);
        layerCard.append('<p class="text-sm text-gray-500 mt-2">Loading data...</p>');
        
        fetch(`/data/${key}`)
            .then(r => r.json())
            .then(geojson => {
                // Remove loading message
                layerCard.find('p').remove();
                
                if (geojson.error) {
                    console.error("Layer fetch error:", geojson.error);
                    showToast(`Failed to load layer "${key}": ${geojson.error}`, 'error');
                    return;
                }
                
                // If the layer already exists on the map, remove it first
                if (leafletLayers[key]) {
                    map.removeLayer(leafletLayers[key]);
                }
                
                // Cache the geojson data for popups and other client-side use
                geojsonCache[key] = geojson;
                
                // Create a new Leaflet GeoJSON layer
                let layer = L.geoJSON(geojson, {
                    // Define styling based on feature type
                    style: feature => getLayerStyle(key),
                    pointToLayer: (feature, latlng) => L.circleMarker(latlng, getLayerStyle(key)),
                    
                    // Attach event handlers to each feature
                    onEachFeature: (feature, layer) => {
                        let props = feature.properties || {};
                        let popupContent = '<div class="font-sans text-sm">';
                        popupContent += `<h4 class="font-bold text-base mb-2">${LAYERS[key].title} Feature</h4>`;
                        for (const [k,v] of Object.entries(props)) {
                            // Don't show the internal rowid in the popup
                            if (k !== '_rowid') {
                                popupContent += `<span class="font-medium text-gray-600">${k}</span>: ${v}<br>`;
                            }
                        }
                        popupContent += '</div>';
                        layer.bindPopup(popupContent, {
                            maxHeight: 200,
                            maxWidth: 300
                        });
                        
                        // Handle click event to highlight the feature and corresponding table row
                        layer.on('click', e => {
                            highlightFeature(key, e.target, feature.properties._rowid);
                            if (activeLayerKey === key && dataTable) {
                                // Find the row in the DataTable and apply the selected-row class
                                $(`#attrTable tbody tr[data-rowid='${feature.properties._rowid}']`).addClass('selected-row');
                            }
                        });
                    }
                }).addTo(map);

                // Store the new layer in our global state
                leafletLayers[key] = layer;
                
                // Zoom to the layer's bounds if requested or if it's the first layer loaded
                if (fitBounds || Object.keys(leafletLayers).length === 1) {
                    map.fitBounds(layer.getBounds(), {padding: [20, 20]});
                }
                
                showToast(`Layer "${LAYERS[key].title}" loaded successfully.`, 'success');
            })
            .catch(error => {
                layerCard.find('p').remove();
                console.error("Fetch failed:", error);
                showToast(`Failed to load data for layer "${key}".`, 'error');
            });
    }

    /**
     * Highlights a single feature on the map and de-highlights previous ones.
     * @param {string} layerKey - The key of the layer the feature belongs to.
     * @param {object} layer - The Leaflet layer object for the feature.
     * @param {number} rowid - The synthetic row ID of the feature.
     */
    function highlightFeature(layerKey, layer, rowid) {
        // Reset the style of the previously highlighted feature
        highlightedFeatures.forEach(h => {
            if (h.layer && h.layerKey && LAYERS[h.layerKey]) {
                h.layer.setStyle(getLayerStyle(h.layerKey));
            }
        });
        highlightedFeatures.clear();

        // Apply the highlight style to the new feature
        layer.setStyle(getLayerStyle(layerKey, true));
        highlightedFeatures.set(rowid, { layerKey, layer });
    }

    /**
     * Dynamically builds the layer list in the sidebar.
     */
    function buildLayerList() {
        const container = $('#layersList');
        container.empty();
        
        if (Object.keys(LAYERS).length === 0) {
            container.html('<p class="text-center text-gray-500 italic p-4">No layers available.</p>');
            return;
        }

        Object.keys(LAYERS).forEach(key => {
            const layer = LAYERS[key];
            const color = layer.color;
            
            // Create a card for each layer with controls
            const card = $(`
                <div class="layer-card" data-key="${key}">
                    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center space-y-2 sm:space-y-0">
                        <div class="flex items-center space-x-2 flex-grow">
                            <input type="checkbox" class="layer-toggle h-4 w-4 text-sky-600 rounded focus:ring-sky-500" data-key="${key}" checked />
                            <input type="checkbox" class="layer-merge-toggle h-4 w-4 text-indigo-600 rounded focus:ring-indigo-500" data-key="${key}" title="Select for merging"/>
                            <span class="font-semibold text-gray-800">${layer.title}</span>
                            <input type="color" class="color-input ml-2" value="${color}" data-key="${key}" />
                        </div>
                        <div class="flex-shrink-0 flex items-center space-x-2">
                            <button class="bg-gray-200 text-gray-700 py-1 px-2 rounded-full hover:bg-gray-300 transition-colors zoom-to-layer" data-key="${key}" title="Zoom to layer"><i class="fas fa-search-plus text-xs"></i></button>
                            <button class="bg-gray-200 text-gray-700 py-1 px-2 rounded-full hover:bg-gray-300 transition-colors view-attributes" data-key="${key}" title="View attributes"><i class="fas fa-table text-xs"></i></button>
                            <button class="bg-red-500 text-white py-1 px-2 rounded-full hover:bg-red-600 transition-colors delete-layer-btn" data-key="${key}" title="Delete layer"><i class="fas fa-trash text-xs"></i></button>
                        </div>
                    </div>
                </div>
            `);
            container.append(card);
        });
    }
    
    /**
     * Fetches and displays the attribute table for a given layer.
     * Uses DataTables for a rich, interactive table experience.
     * @param {string} layerKey - The key of the layer.
     */
    function loadAttributeTable(layerKey) {
        $('#tableArea').html('<p class="text-center text-gray-500 italic p-4">Loading attributes...</p>');
        selectedRows[layerKey] = new Set();
        $('#createSelectionLayerBtn, #downloadSelectionBtn').prop('disabled', true);
        
        // Fetch attribute data from the backend
        $.getJSON(`/attributes/${layerKey}`, function(data) {
            if (data.error) {
                $('#tableArea').html(`<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
                                        <p class="font-bold">Error</p>
                                        <p class="block sm:inline">${data.error}</p>
                                    </div>`);
                return;
            }
            
            // Destroy any existing DataTables instance
            if (dataTable) {
                dataTable.destroy();
            }
            
            // Build the table header and body HTML dynamically
            let columns = data.columns.filter(col => col !== '_rowid');
            let rows = data.rows;

            let html = `<table id="attrTable" class="min-w-full divide-y divide-gray-200 text-sm">
                <thead class="bg-gray-50">
                    <tr>
                        <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                            <input type="checkbox" id="selectAll" class="h-4 w-4 text-sky-600 rounded focus:ring-sky-500" />
                        </th>`;
            columns.forEach(col => {
                html += `<th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${col}</th>`;
            });
            html += '</tr></thead><tbody class="bg-white divide-y divide-gray-200">';

            rows.forEach(row => {
                html += `<tr data-rowid="${row._rowid}" class="hover:bg-gray-100 transition-colors duration-150">
                            <td class="px-6 py-4 whitespace-nowrap"><input type="checkbox" class="row-select h-4 w-4 text-sky-600 rounded focus:ring-sky-500"/></td>`;
                columns.forEach(col => {
                    html += `<td class="px-6 py-4 whitespace-nowrap text-gray-700">${row[col]}</td>`;
                });
                html += '</tr>';
            });
            html += '</tbody></table>';

            // Insert the table into the DOM and initialize DataTables
            $('#tableArea').html(html);
            
            dataTable = $('#attrTable').DataTable({
                scrollY: "300px",
                scrollCollapse: true,
                paging: false,
                info: false,
                searching: true,
                columnDefs: [{ orderable: false, targets: 0 }],
                "dom": '<"flex items-center justify-between p-4 bg-white rounded-t-lg shadow-md"f<"text-sm"i>>' +
                    '<"overflow-x-auto"t>'
            });

            // Event listeners for the new table
            $('#attrTable tbody').on('click', 'tr', function() {
                const rowid = parseInt($(this).data('rowid'));
                if (activeLayerKey && leafletLayers[activeLayerKey]) {
                    const layer = leafletLayers[activeLayerKey].getLayers().find(l => l.feature.properties._rowid === rowid);
                    if (layer) {
                        highlightFeature(activeLayerKey, layer, rowid);
                    }
                }
            });

            $('#attrTable tbody').on('change', '.row-select', function() {
                const rowid = parseInt($(this).closest('tr').data('rowid'));
                if (!selectedRows[activeLayerKey]) selectedRows[activeLayerKey] = new Set();
                
                if (this.checked) {
                    selectedRows[activeLayerKey].add(rowid);
                    $(this).closest('tr').addClass('selected-row');
                } else {
                    selectedRows[activeLayerKey].delete(rowid);
                    $(this).closest('tr').removeClass('selected-row');
                }
                updateSelectionButtons();
            });

            $('#selectAll').on('click', function() {
                const isChecked = this.checked;
                $('.row-select').prop('checked', isChecked).trigger('change');
            });
            
            showToast(`Attribute table for "${LAYERS[layerKey].title}" loaded.`, 'info');
        
        }).fail(() => {
            $('#tableArea').html(`<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
                                    <p class="font-bold">Error</p>
                                    <p class="block sm:inline">Failed to fetch layer attributes. Please try again.</p>
                                </div>`);
            showToast('Failed to fetch layer attributes.', 'error');
        });
    }

    /**
     * Enables or disables the selection-related buttons based on whether a selection exists.
     */
    function updateSelectionButtons() {
        const hasSelection = selectedRows[activeLayerKey] && selectedRows[activeLayerKey].size > 0;
        $('#createSelectionLayerBtn, #downloadSelectionBtn').prop('disabled', !hasSelection);
        
        // Update merge button state based on selected layers for merging
        const hasMergeSelection = $('.layer-merge-toggle:checked').length >= 2;
        $('#mergeLayersBtn').prop('disabled', !hasMergeSelection);
    }

    /**
     * Creates a new layer from the currently selected features.
     * Not implemented on the backend yet, but the front end code is ready.
     * @param {string} baseLayerKey - The key of the original layer.
     * @param {Array<number>} selectedRowids - An array of the selected row IDs.
     */
    function createSelectionLayer(baseLayerKey, selectedRowids) {
        // This function would make a POST request to a new backend endpoint.
        // For now, it's a placeholder for future functionality.
        showToast('This feature is not yet implemented on the server-side.', 'info');
    }
    
    /**
     * Sends a request to download the selected features.
     * @param {string} layerKey - The key of the layer to download from.
     * @param {Array<number>} selectedRowids - The IDs of the selected features.
     */
    function downloadSelection(layerKey, selectedRowids) {
        // Send a POST request to the download endpoint
        fetch('/download', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({ layer: layerKey, selected: selectedRowids })
        }).then(resp => {
            if (resp.ok) {
                // If successful, get the file as a Blob and trigger a download
                return resp.blob();
            } else {
                // If not successful, parse the error message from the response JSON
                return resp.json().then(error => Promise.reject(error));
            }
        }).then(blob => {
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `${layerKey}_selection.zip`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            a.remove();
            showToast(`Download for "${LAYERS[layerKey].title}" started.`, 'success');
        }).catch(err => {
            console.error("Download failed:", err);
            showToast(`Download failed: ${err.error || 'Unknown error'}`, 'error');
        });
    }

    /**
     * Deletes a layer from the database and the map.
     * @param {string} layerKey - The key of the layer to delete.
     */
    function deleteLayer(layerKey) {
        fetch(`/delete_layer/${layerKey}`, {
            method: 'DELETE'
        }).then(resp => resp.json()).then(data => {
            if (data.error) {
                showToast(`Error deleting layer: ${data.error}`, 'error');
            } else {
                showToast(data.success, 'success');
                // Remove the layer from the map and internal state
                if (leafletLayers[layerKey]) {
                    map.removeLayer(leafletLayers[layerKey]);
                    delete leafletLayers[layerKey];
                }
                delete LAYERS[layerKey];
                
                // If the active layer was deleted, reset the attribute table area
                if (layerKey === activeLayerKey) {
                    activeLayerKey = null;
                    if (dataTable) {
                        dataTable.destroy();
                        dataTable = null;
                    }
                    $('#tableArea').html('<p class="text-center text-gray-500 p-4">Select a layer to view its data.</p>');
                }
                
                // Rebuild the layer list to reflect the change
                buildLayerList();
                // Close the modal
                $('#deleteModal').hide();
            }
        }).catch(err => {
            console.error("Delete failed:", err);
            showToast('Failed to connect to server to delete layer.', 'error');
        });
    }
    
    /**
     * Merges selected layers from the sidebar.
     */
    function mergeLayers() {
        const layersToMerge = [];
        $('.layer-merge-toggle:checked').each(function() {
            const key = $(this).data('key');
            if (selectedRows[key] && selectedRows[key].size > 0) {
                 layersToMerge.push({
                     layer: key,
                     selected: Array.from(selectedRows[key])
                 });
            } else {
                // If no features are selected for a layer marked for merging, merge the whole layer
                const layer = LAYERS[key];
                if (layer) {
                    // This is a simplified way, in a real app you might need to query the server
                    // for all row IDs. For this example, we assume we want all features.
                    // This is a placeholder for a more complex implementation.
                    layersToMerge.push({
                        layer: key,
                        selected: Array.from({length: geojsonCache[key]?.features?.length || 0}, (_, i) => i)
                    });
                }
            }
        });

        if (layersToMerge.length < 2) {
            return showToast('Please select at least two layers to merge.', 'info');
        }

        // Send a request to the backend to perform the merge
        showToast('Merging layers...', 'info');
        fetch('/merge_layers', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({ layers: layersToMerge })
        }).then(resp => {
            if (resp.ok) {
                return resp.blob();
            } else {
                return resp.json().then(error => Promise.reject(error));
            }
        }).then(blob => {
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = `merged_layers.zip`;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            a.remove();
            showToast('Merged layers downloaded successfully!', 'success');
        }).catch(err => {
            console.error("Merge failed:", err);
            showToast(`Failed to merge layers: ${err.error || 'Unknown error'}`, 'error');
        });
    }


    /*
    * ========================================
    * EVENT LISTENERS
    * ========================================
    */

    // This block runs when the entire document is loaded
    $(document).ready(() => {
        // Initial setup of the layer list
        buildLayerList();
        
        // Load all layers onto the map initially if they exist
        if (Object.keys(LAYERS).length > 0) {
            Object.keys(LAYERS).forEach(key => addLayerToMap(key));
        } else {
            $('#layersList').html('<p class="text-center text-gray-500 italic p-4">No layers available. Use the "Upload Layer" button to add one.</p>');
        }
        
        // Event delegation for dynamically added layer controls
        const layersListContainer = $('#layersList');

        // Toggle layer visibility
        layersListContainer.on('change', '.layer-toggle', function() {
            const key = $(this).data('key');
            if ($(this).is(':checked')) {
                if (leafletLayers[key]) {
                    map.addLayer(leafletLayers[key]);
                } else {
                    addLayerToMap(key);
                }
            } else {
                if (leafletLayers[key]) {
                    map.removeLayer(leafletLayers[key]);
                }
                if (key === activeLayerKey) {
                    $('#tableArea').html('<p class="text-center text-gray-500 italic p-4">Select a layer to view its data.</p>');
                }
            }
        });

        // Change layer color
        layersListContainer.on('change', '.color-input', function() {
            const key = $(this).data('key');
            const newColor = $(this).val();
            LAYERS[key].color = newColor;
            if (leafletLayers[key]) {
                leafletLayers[key].eachLayer(layer => {
                    layer.setStyle(getLayerStyle(key));
                });
            }
        });

        // Zoom to layer extent
        layersListContainer.on('click', '.zoom-to-layer', function() {
            const key = $(this).data('key');
            if (!leafletLayers[key]) {
                return showToast('Layer not yet loaded on map.', 'info');
            }
            map.fitBounds(leafletLayers[key].getBounds(), {padding: [20, 20]});
        });

        // View attribute table
        layersListContainer.on('click', '.view-attributes', function() {
            const key = $(this).data('key');
            activeLayerKey = key;
            loadAttributeTable(key);
        });

        // Show delete confirmation modal
        let layerToDeleteKey = null;
        layersListContainer.on('click', '.delete-layer-btn', function() {
            layerToDeleteKey = $(this).data('key');
            $('#deleteLayerName').text(LAYERS[layerToDeleteKey].title);
            $('#deleteModal').show();
        });

        // Confirm deletion
        $('#confirmDeleteBtn').on('click', () => {
            if (layerToDeleteKey) {
                deleteLayer(layerToDeleteKey);
            }
        });
        
        // Main toolbar buttons
        $('#uploadBtn').on('click', () => $('#uploadModal').show());
        $('#refreshLayersBtn').on('click', () => window.location.reload());
        $('#mergeLayersBtn').on('click', () => mergeLayers());
        
        // Handle selection buttons
        $('#createSelectionLayerBtn').on('click', () => {
            if (!activeLayerKey || !selectedRows[activeLayerKey] || selectedRows[activeLayerKey].size === 0) {
                return showToast('No features selected to create a layer.', 'error');
            }
            const selected = Array.from(selectedRows[activeLayerKey]);
            createSelectionLayer(activeLayerKey, selected);
        });
        
        $('#downloadSelectionBtn').on('click', () => {
            if (!activeLayerKey || !selectedRows[activeLayerKey] || selectedRows[activeLayerKey].size === 0) {
                return showToast('No features selected to download.', 'error');
            }
            const selected = Array.from(selectedRows[activeLayerKey]);
            downloadSelection(activeLayerKey, selected);
        });
        
        // Handle modal close buttons
        $('.close-modal').on('click', function() {
            $(this).closest('.fixed').hide();
        });

        // Handle file upload form submission
        $('#uploadForm').submit(function(e){
            e.preventDefault();
            $('#uploadStatus').html('');
            
            const formData = new FormData(this);
            showToast('Uploading layer...', 'info');
            
            $.ajax({
                url: '/upload',
                type: 'POST',
                data: formData,
                processData: false,
                contentType: false,
                success: res => {
                    if (res.error) {
                        $('#uploadStatus').html(`<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
                                                    <p class="font-bold">Error</p>
                                                    <p class="block sm:inline">${res.error}</p>
                                                </div>`);
                        showToast(`Upload failed: ${res.error}`, 'error');
                    } else {
                        $('#uploadStatus').html(`<div class="bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded relative" role="alert">
                                                    <p class="font-bold">Success!</p>
                                                    <p class="block sm:inline">${res.success}</p>
                                                </div>`);
                        // Reload the page to show the new layer and reset the state
                        window.location.reload();
                    }
                },
                error: xhr => {
                    const errorMsg = xhr.responseJSON?.error || xhr.statusText;
                    $('#uploadStatus').html(`<div class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
                                                <p class="font-bold">Error</p>
                                                <p class="block sm:inline">Upload failed: ${errorMsg}</p>
                                            </div>`);
                    showToast(`Upload failed: ${errorMsg}`, 'error');
                }
            });
        });
    });
</script>
</body>
</html>
